                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.5.0 #9253 (Mar 24 2016) (Linux)
                              4 ; This file was generated Thu Nov  3 14:04:53 2016
                              5 ;--------------------------------------------------------
                              6 	.module mmc
                              7 	.optsdcc -mz80
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _forward
                             13 	.globl _dly_us
                             14 	.globl _disk_initialize
                             15 	.globl _disk_readp
                             16 ;--------------------------------------------------------
                             17 ; special function registers
                             18 ;--------------------------------------------------------
                     0000    19 _DataPort	=	0x0000
                     0001    20 _ControlPort	=	0x0001
                             21 ;--------------------------------------------------------
                             22 ; ram data
                             23 ;--------------------------------------------------------
                             24 	.area _DATA
   0000                      25 _buffer:
   0000                      26 	.ds 512
   0200                      27 _CardType:
   0200                      28 	.ds 1
                             29 ;--------------------------------------------------------
                             30 ; ram data
                             31 ;--------------------------------------------------------
                             32 	.area _INITIALIZED
   0000                      33 _buffer_sector:
   0000                      34 	.ds 4
                             35 ;--------------------------------------------------------
                             36 ; absolute external ram data
                             37 ;--------------------------------------------------------
                             38 	.area _DABS (ABS)
                             39 ;--------------------------------------------------------
                             40 ; global & static initialisations
                             41 ;--------------------------------------------------------
                             42 	.area _HOME
                             43 	.area _GSINIT
                             44 	.area _GSFINAL
                             45 	.area _GSINIT
                             46 ;--------------------------------------------------------
                             47 ; Home
                             48 ;--------------------------------------------------------
                             49 	.area _HOME
                             50 	.area _HOME
                             51 ;--------------------------------------------------------
                             52 ; code
                             53 ;--------------------------------------------------------
                             54 	.area _CODE
                             55 ;mmc.c:29: void dly_us(unsigned char n) {
                             56 ;	---------------------------------
                             57 ; Function dly_us
                             58 ; ---------------------------------
   0000                      59 _dly_us::
                             60 ;mmc.c:30: while(n--);
   0000 21 02 00      [10]   61 	ld	hl, #2+0
   0003 39            [11]   62 	add	hl, sp
   0004 56            [ 7]   63 	ld	d, (hl)
   0005                      64 00101$:
   0005 5A            [ 4]   65 	ld	e,d
   0006 15            [ 4]   66 	dec	d
   0007 7B            [ 4]   67 	ld	a,e
   0008 B7            [ 4]   68 	or	a, a
   0009 20 FA         [12]   69 	jr	NZ,00101$
   000B C9            [10]   70 	ret
                             71 ;mmc.c:33: void forward(BYTE n) {
                             72 ;	---------------------------------
                             73 ; Function forward
                             74 ; ---------------------------------
   000C                      75 _forward::
                             76 ;mmc.c:34: }
   000C C9            [10]   77 	ret
                             78 ;mmc.c:85: BYTE rcvr_mmc (void)
                             79 ;	---------------------------------
                             80 ; Function rcvr_mmc
                             81 ; ---------------------------------
   000D                      82 _rcvr_mmc:
                             83 ;mmc.c:87: DataPort = 0xff;
   000D 3E FF         [ 7]   84 	ld	a,#0xFF
   000F D3 00         [11]   85 	out	(_DataPort),a
                             86 ;mmc.c:94: __endasm;
   0011 00            [ 4]   87 	nop
   0012 00            [ 4]   88 	nop
                             89 ;mmc.c:96: return DataPort;
   0013 DB 00         [11]   90 	in	a,(_DataPort)
   0015 6F            [ 4]   91 	ld	l,a
   0016 C9            [10]   92 	ret
                             93 ;mmc.c:104: void skip_mmc (
                             94 ;	---------------------------------
                             95 ; Function skip_mmc
                             96 ; ---------------------------------
   0017                      97 _skip_mmc:
                             98 ;mmc.c:108: do {
   0017 C1            [10]   99 	pop	bc
   0018 D1            [10]  100 	pop	de
   0019 D5            [11]  101 	push	de
   001A C5            [11]  102 	push	bc
   001B                     103 00101$:
                            104 ;mmc.c:109: DataPort = 0xff;
   001B 3E FF         [ 7]  105 	ld	a,#0xFF
   001D D3 00         [11]  106 	out	(_DataPort),a
                            107 ;mmc.c:110: } while (--n);
   001F 1B            [ 6]  108 	dec	de
   0020 7A            [ 4]  109 	ld	a,d
   0021 B3            [ 4]  110 	or	a,e
   0022 20 F7         [12]  111 	jr	NZ,00101$
   0024 C9            [10]  112 	ret
                            113 ;mmc.c:120: void release_spi (void)
                            114 ;	---------------------------------
                            115 ; Function release_spi
                            116 ; ---------------------------------
   0025                     117 _release_spi:
                            118 ;mmc.c:122: CS_H();
   0025 3E 01         [ 7]  119 	ld	a,#0x01
   0027 D3 01         [11]  120 	out	(_ControlPort),a
                            121 ;mmc.c:123: rcvr_mmc();
   0029 C3r0Dr00      [10]  122 	jp	_rcvr_mmc
                            123 ;mmc.c:132: BYTE send_cmd (
                            124 ;	---------------------------------
                            125 ; Function send_cmd
                            126 ; ---------------------------------
   002C                     127 _send_cmd:
   002C DD E5         [15]  128 	push	ix
   002E DD 21 00 00   [14]  129 	ld	ix,#0
   0032 DD 39         [15]  130 	add	ix,sp
                            131 ;mmc.c:140: if (cmd & 0x80) {	/* ACMD<n> is the command sequense of CMD55-CMD<n> */
   0034 DD CB 04 7E   [20]  132 	bit	7, 4 (ix)
   0038 28 1C         [12]  133 	jr	Z,00104$
                            134 ;mmc.c:141: cmd &= 0x7F;
   003A DD CB 04 BE   [23]  135 	res	7, 4 (ix)
                            136 ;mmc.c:142: res = send_cmd(CMD55, 0);
   003E 21 00 00      [10]  137 	ld	hl,#0x0000
   0041 E5            [11]  138 	push	hl
   0042 21 00 00      [10]  139 	ld	hl,#0x0000
   0045 E5            [11]  140 	push	hl
   0046 3E 77         [ 7]  141 	ld	a,#0x77
   0048 F5            [11]  142 	push	af
   0049 33            [ 6]  143 	inc	sp
   004A CDr2Cr00      [17]  144 	call	_send_cmd
   004D F1            [10]  145 	pop	af
   004E F1            [10]  146 	pop	af
   004F 33            [ 6]  147 	inc	sp
                            148 ;mmc.c:143: if (res > 1) return res;
   0050 3E 01         [ 7]  149 	ld	a,#0x01
   0052 95            [ 4]  150 	sub	a, l
   0053 DArEAr00      [10]  151 	jp	C,00113$
   0056                     152 00104$:
                            153 ;mmc.c:147: CS_H(); rcvr_mmc();
   0056 3E 01         [ 7]  154 	ld	a,#0x01
   0058 D3 01         [11]  155 	out	(_ControlPort),a
   005A CDr0Dr00      [17]  156 	call	_rcvr_mmc
                            157 ;mmc.c:148: CS_L(); rcvr_mmc();
   005D 3E 00         [ 7]  158 	ld	a,#0x00
   005F D3 01         [11]  159 	out	(_ControlPort),a
   0061 CDr0Dr00      [17]  160 	call	_rcvr_mmc
                            161 ;mmc.c:151: XMIT_MMC(cmd);					/* Start + Command index */
   0064 DD 7E 04      [19]  162 	ld	a,4 (ix)
   0067 D3 00         [11]  163 	out	(_DataPort),a
                            164 ;mmc.c:152: XMIT_MMC((BYTE)(arg >> 24));	/* Argument[31..24] */
   0069 F5            [11]  165 	push	af
   006A DD 6E 05      [19]  166 	ld	l,5 (ix)
   006D DD 66 06      [19]  167 	ld	h,6 (ix)
   0070 DD 5E 07      [19]  168 	ld	e,7 (ix)
   0073 DD 56 08      [19]  169 	ld	d,8 (ix)
   0076 F1            [10]  170 	pop	af
   0077 06 18         [ 7]  171 	ld	b,#0x18
   0079                     172 00141$:
   0079 CB 3A         [ 8]  173 	srl	d
   007B CB 1B         [ 8]  174 	rr	e
   007D CB 1C         [ 8]  175 	rr	h
   007F CB 1D         [ 8]  176 	rr	l
   0081 10 F6         [13]  177 	djnz	00141$
   0083 7D            [ 4]  178 	ld	a,l
   0084 D3 00         [11]  179 	out	(_DataPort),a
                            180 ;mmc.c:153: XMIT_MMC((BYTE)(arg >> 16));	/* Argument[23..16] */
   0086 F5            [11]  181 	push	af
   0087 DD 6E 05      [19]  182 	ld	l,5 (ix)
   008A DD 66 06      [19]  183 	ld	h,6 (ix)
   008D DD 5E 07      [19]  184 	ld	e,7 (ix)
   0090 DD 56 08      [19]  185 	ld	d,8 (ix)
   0093 F1            [10]  186 	pop	af
   0094 06 10         [ 7]  187 	ld	b,#0x10
   0096                     188 00143$:
   0096 CB 3A         [ 8]  189 	srl	d
   0098 CB 1B         [ 8]  190 	rr	e
   009A CB 1C         [ 8]  191 	rr	h
   009C CB 1D         [ 8]  192 	rr	l
   009E 10 F6         [13]  193 	djnz	00143$
   00A0 7D            [ 4]  194 	ld	a,l
   00A1 D3 00         [11]  195 	out	(_DataPort),a
                            196 ;mmc.c:154: XMIT_MMC((BYTE)(arg >> 8));		/* Argument[15..8] */
   00A3 F5            [11]  197 	push	af
   00A4 DD 66 05      [19]  198 	ld	h,5 (ix)
   00A7 DD 6E 06      [19]  199 	ld	l,6 (ix)
   00AA DD 5E 07      [19]  200 	ld	e,7 (ix)
   00AD DD 56 08      [19]  201 	ld	d,8 (ix)
   00B0 F1            [10]  202 	pop	af
   00B1 06 08         [ 7]  203 	ld	b,#0x08
   00B3                     204 00145$:
   00B3 CB 3A         [ 8]  205 	srl	d
   00B5 CB 1B         [ 8]  206 	rr	e
   00B7 CB 1D         [ 8]  207 	rr	l
   00B9 CB 1C         [ 8]  208 	rr	h
   00BB 10 F6         [13]  209 	djnz	00145$
   00BD 7C            [ 4]  210 	ld	a,h
   00BE D3 00         [11]  211 	out	(_DataPort),a
                            212 ;mmc.c:155: XMIT_MMC((BYTE)arg);			/* Argument[7..0] */
   00C0 DD 7E 05      [19]  213 	ld	a,5 (ix)
   00C3 D3 00         [11]  214 	out	(_DataPort),a
                            215 ;mmc.c:156: n = 0x01;						/* Dummy CRC + Stop */
   00C5 26 01         [ 7]  216 	ld	h,#0x01
                            217 ;mmc.c:157: if (cmd == CMD0) n = 0x95;		/* Valid CRC for CMD0(0) */
   00C7 DD 7E 04      [19]  218 	ld	a,4 (ix)
   00CA D6 40         [ 7]  219 	sub	a, #0x40
   00CC 20 02         [12]  220 	jr	NZ,00106$
   00CE 26 95         [ 7]  221 	ld	h,#0x95
   00D0                     222 00106$:
                            223 ;mmc.c:158: if (cmd == CMD8) n = 0x87;		/* Valid CRC for CMD8(0x1AA) */
   00D0 DD 7E 04      [19]  224 	ld	a,4 (ix)
   00D3 D6 48         [ 7]  225 	sub	a, #0x48
   00D5 20 02         [12]  226 	jr	NZ,00108$
   00D7 26 87         [ 7]  227 	ld	h,#0x87
   00D9                     228 00108$:
                            229 ;mmc.c:159: XMIT_MMC(n);
   00D9 7C            [ 4]  230 	ld	a,h
   00DA D3 00         [11]  231 	out	(_DataPort),a
                            232 ;mmc.c:163: do {
   00DC 16 0A         [ 7]  233 	ld	d,#0x0A
   00DE                     234 00110$:
                            235 ;mmc.c:164: res = rcvr_mmc();
   00DE D5            [11]  236 	push	de
   00DF CDr0Dr00      [17]  237 	call	_rcvr_mmc
   00E2 D1            [10]  238 	pop	de
                            239 ;mmc.c:165: } while ((res & 0x80) && --n);
   00E3 CB 7D         [ 8]  240 	bit	7, l
   00E5 28 03         [12]  241 	jr	Z,00112$
   00E7 15            [ 4]  242 	dec d
   00E8 20 F4         [12]  243 	jr	NZ,00110$
   00EA                     244 00112$:
                            245 ;mmc.c:167: return res;			/* Return with the response value */
   00EA                     246 00113$:
   00EA DD E1         [14]  247 	pop	ix
   00EC C9            [10]  248 	ret
                            249 ;mmc.c:183: DSTATUS disk_initialize (void)
                            250 ;	---------------------------------
                            251 ; Function disk_initialize
                            252 ; ---------------------------------
   00ED                     253 _disk_initialize::
   00ED DD E5         [15]  254 	push	ix
   00EF DD 21 00 00   [14]  255 	ld	ix,#0
   00F3 DD 39         [15]  256 	add	ix,sp
   00F5 21 FA FF      [10]  257 	ld	hl,#-6
   00F8 39            [11]  258 	add	hl,sp
   00F9 F9            [ 6]  259 	ld	sp,hl
                            260 ;mmc.c:188: CS_H();
   00FA 3E 01         [ 7]  261 	ld	a,#0x01
   00FC D3 01         [11]  262 	out	(_ControlPort),a
                            263 ;mmc.c:189: skip_mmc(10);			/* Dummy clocks */
   00FE 21 0A 00      [10]  264 	ld	hl,#0x000A
   0101 E5            [11]  265 	push	hl
   0102 CDr17r00      [17]  266 	call	_skip_mmc
   0105 F1            [10]  267 	pop	af
                            268 ;mmc.c:191: ty = 0;
   0106 0E 00         [ 7]  269 	ld	c,#0x00
                            270 ;mmc.c:192: if (send_cmd(CMD0, 0) == 1) {			/* Enter Idle state */
   0108 C5            [11]  271 	push	bc
   0109 21 00 00      [10]  272 	ld	hl,#0x0000
   010C E5            [11]  273 	push	hl
   010D 21 00 00      [10]  274 	ld	hl,#0x0000
   0110 E5            [11]  275 	push	hl
   0111 3E 40         [ 7]  276 	ld	a,#0x40
   0113 F5            [11]  277 	push	af
   0114 33            [ 6]  278 	inc	sp
   0115 CDr2Cr00      [17]  279 	call	_send_cmd
   0118 F1            [10]  280 	pop	af
   0119 F1            [10]  281 	pop	af
   011A 33            [ 6]  282 	inc	sp
   011B C1            [10]  283 	pop	bc
   011C 2D            [ 4]  284 	dec	l
   011D C2r4Er02      [10]  285 	jp	NZ,00125$
                            286 ;mmc.c:193: if (send_cmd(CMD8, 0x1AA) == 1) {	/* SDv2 */
   0120 C5            [11]  287 	push	bc
   0121 21 00 00      [10]  288 	ld	hl,#0x0000
   0124 E5            [11]  289 	push	hl
   0125 21 AA 01      [10]  290 	ld	hl,#0x01AA
   0128 E5            [11]  291 	push	hl
   0129 3E 48         [ 7]  292 	ld	a,#0x48
   012B F5            [11]  293 	push	af
   012C 33            [ 6]  294 	inc	sp
   012D CDr2Cr00      [17]  295 	call	_send_cmd
   0130 F1            [10]  296 	pop	af
   0131 F1            [10]  297 	pop	af
   0132 33            [ 6]  298 	inc	sp
   0133 C1            [10]  299 	pop	bc
   0134 2D            [ 4]  300 	dec	l
   0135 C2rE5r01      [10]  301 	jp	NZ,00122$
                            302 ;mmc.c:194: for (n = 0; n < 4; n++) buf[n] = rcvr_mmc();	/* Get trailing return value of R7 resp */
   0138 21 02 00      [10]  303 	ld	hl,#0x0002
   013B 39            [11]  304 	add	hl,sp
   013C EB            [ 4]  305 	ex	de,hl
   013D 06 00         [ 7]  306 	ld	b,#0x00
   013F                     307 00126$:
   013F 68            [ 4]  308 	ld	l,b
   0140 26 00         [ 7]  309 	ld	h,#0x00
   0142 19            [11]  310 	add	hl,de
   0143 E5            [11]  311 	push	hl
   0144 C5            [11]  312 	push	bc
   0145 D5            [11]  313 	push	de
   0146 CDr0Dr00      [17]  314 	call	_rcvr_mmc
   0149 7D            [ 4]  315 	ld	a,l
   014A D1            [10]  316 	pop	de
   014B C1            [10]  317 	pop	bc
   014C E1            [10]  318 	pop	hl
   014D 77            [ 7]  319 	ld	(hl),a
   014E 04            [ 4]  320 	inc	b
   014F 78            [ 4]  321 	ld	a,b
   0150 D6 04         [ 7]  322 	sub	a, #0x04
   0152 38 EB         [12]  323 	jr	C,00126$
                            324 ;mmc.c:195: if (buf[2] == 0x01 && buf[3] == 0xAA) {			/* The card can work at vdd range of 2.7-3.6V */
   0154 6B            [ 4]  325 	ld	l, e
   0155 62            [ 4]  326 	ld	h, d
   0156 23            [ 6]  327 	inc	hl
   0157 23            [ 6]  328 	inc	hl
   0158 7E            [ 7]  329 	ld	a,(hl)
   0159 3D            [ 4]  330 	dec	a
   015A C2r4Er02      [10]  331 	jp	NZ,00125$
   015D D5            [11]  332 	push	de
   015E FD E1         [14]  333 	pop	iy
   0160 FD 7E 03      [19]  334 	ld	a,3 (iy)
   0163 D6 AA         [ 7]  335 	sub	a, #0xAA
   0165 C2r4Er02      [10]  336 	jp	NZ,00125$
                            337 ;mmc.c:196: for (tmr = 1000; tmr; tmr--) {				/* Wait for leaving idle state (ACMD41 with HCS bit) */
   0168 21 E8 03      [10]  338 	ld	hl,#0x03E8
   016B E3            [19]  339 	ex	(sp), hl
   016C                     340 00128$:
                            341 ;mmc.c:197: if (send_cmd(ACMD41, 1UL << 30) == 0) break;
   016C C5            [11]  342 	push	bc
   016D D5            [11]  343 	push	de
   016E 21 00 40      [10]  344 	ld	hl,#0x4000
   0171 E5            [11]  345 	push	hl
   0172 21 00 00      [10]  346 	ld	hl,#0x0000
   0175 E5            [11]  347 	push	hl
   0176 3E E9         [ 7]  348 	ld	a,#0xE9
   0178 F5            [11]  349 	push	af
   0179 33            [ 6]  350 	inc	sp
   017A CDr2Cr00      [17]  351 	call	_send_cmd
   017D F1            [10]  352 	pop	af
   017E F1            [10]  353 	pop	af
   017F 33            [ 6]  354 	inc	sp
   0180 7D            [ 4]  355 	ld	a,l
   0181 D1            [10]  356 	pop	de
   0182 C1            [10]  357 	pop	bc
   0183 B7            [ 4]  358 	or	a, a
   0184 28 18         [12]  359 	jr	Z,00104$
                            360 ;mmc.c:198: DLY_US(1000);
   0186 C5            [11]  361 	push	bc
   0187 D5            [11]  362 	push	de
   0188 3E E8         [ 7]  363 	ld	a,#0xE8
   018A F5            [11]  364 	push	af
   018B 33            [ 6]  365 	inc	sp
   018C CDr00r00      [17]  366 	call	_dly_us
   018F 33            [ 6]  367 	inc	sp
   0190 D1            [10]  368 	pop	de
   0191 C1            [10]  369 	pop	bc
                            370 ;mmc.c:196: for (tmr = 1000; tmr; tmr--) {				/* Wait for leaving idle state (ACMD41 with HCS bit) */
   0192 E1            [10]  371 	pop	hl
   0193 E5            [11]  372 	push	hl
   0194 2B            [ 6]  373 	dec	hl
   0195 E3            [19]  374 	ex	(sp), hl
   0196 DD 7E FB      [19]  375 	ld	a,-5 (ix)
   0199 DD B6 FA      [19]  376 	or	a,-6 (ix)
   019C 20 CE         [12]  377 	jr	NZ,00128$
   019E                     378 00104$:
                            379 ;mmc.c:200: if (tmr && send_cmd(CMD58, 0) == 0) {		/* Check CCS bit in the OCR */
   019E DD 7E FB      [19]  380 	ld	a,-5 (ix)
   01A1 DD B6 FA      [19]  381 	or	a,-6 (ix)
   01A4 CAr4Er02      [10]  382 	jp	Z,00125$
   01A7 C5            [11]  383 	push	bc
   01A8 D5            [11]  384 	push	de
   01A9 21 00 00      [10]  385 	ld	hl,#0x0000
   01AC E5            [11]  386 	push	hl
   01AD 21 00 00      [10]  387 	ld	hl,#0x0000
   01B0 E5            [11]  388 	push	hl
   01B1 3E 7A         [ 7]  389 	ld	a,#0x7A
   01B3 F5            [11]  390 	push	af
   01B4 33            [ 6]  391 	inc	sp
   01B5 CDr2Cr00      [17]  392 	call	_send_cmd
   01B8 F1            [10]  393 	pop	af
   01B9 F1            [10]  394 	pop	af
   01BA 33            [ 6]  395 	inc	sp
   01BB 7D            [ 4]  396 	ld	a,l
   01BC D1            [10]  397 	pop	de
   01BD C1            [10]  398 	pop	bc
                            399 ;mmc.c:201: for (n = 0; n < 4; n++) buf[n] = rcvr_mmc();
   01BE B7            [ 4]  400 	or	a,a
   01BF C2r4Er02      [10]  401 	jp	NZ,00125$
   01C2 47            [ 4]  402 	ld	b,a
   01C3                     403 00130$:
   01C3 68            [ 4]  404 	ld	l,b
   01C4 26 00         [ 7]  405 	ld	h,#0x00
   01C6 19            [11]  406 	add	hl,de
   01C7 E5            [11]  407 	push	hl
   01C8 C5            [11]  408 	push	bc
   01C9 D5            [11]  409 	push	de
   01CA CDr0Dr00      [17]  410 	call	_rcvr_mmc
   01CD 7D            [ 4]  411 	ld	a,l
   01CE D1            [10]  412 	pop	de
   01CF C1            [10]  413 	pop	bc
   01D0 E1            [10]  414 	pop	hl
   01D1 77            [ 7]  415 	ld	(hl),a
   01D2 04            [ 4]  416 	inc	b
   01D3 78            [ 4]  417 	ld	a,b
   01D4 D6 04         [ 7]  418 	sub	a, #0x04
   01D6 38 EB         [12]  419 	jr	C,00130$
                            420 ;mmc.c:202: ty = (buf[0] & 0x40) ? CT_SD2 | CT_BLOCK : CT_SD2;	/* SDv2 (HC or SC) */
   01D8 1A            [ 7]  421 	ld	a,(de)
   01D9 CB 77         [ 8]  422 	bit	6, a
   01DB 28 04         [12]  423 	jr	Z,00136$
   01DD 0E 0C         [ 7]  424 	ld	c,#0x0C
   01DF 18 6D         [12]  425 	jr	00125$
   01E1                     426 00136$:
   01E1 0E 04         [ 7]  427 	ld	c,#0x04
   01E3 18 69         [12]  428 	jr	00125$
   01E5                     429 00122$:
                            430 ;mmc.c:206: if (send_cmd(ACMD41, 0) <= 1) 	{
   01E5 21 00 00      [10]  431 	ld	hl,#0x0000
   01E8 E5            [11]  432 	push	hl
   01E9 21 00 00      [10]  433 	ld	hl,#0x0000
   01EC E5            [11]  434 	push	hl
   01ED 3E E9         [ 7]  435 	ld	a,#0xE9
   01EF F5            [11]  436 	push	af
   01F0 33            [ 6]  437 	inc	sp
   01F1 CDr2Cr00      [17]  438 	call	_send_cmd
   01F4 F1            [10]  439 	pop	af
   01F5 F1            [10]  440 	pop	af
   01F6 33            [ 6]  441 	inc	sp
   01F7 3E 01         [ 7]  442 	ld	a,#0x01
   01F9 95            [ 4]  443 	sub	a, l
   01FA 38 05         [12]  444 	jr	C,00113$
                            445 ;mmc.c:207: ty = CT_SD1; cmd = ACMD41;	/* SDv1 */
   01FC 01 02 E9      [10]  446 	ld	bc,#0xE902
   01FF 18 03         [12]  447 	jr	00155$
   0201                     448 00113$:
                            449 ;mmc.c:209: ty = CT_MMC; cmd = CMD1;	/* MMCv3 */
   0201 01 01 41      [10]  450 	ld	bc,#0x4101
                            451 ;mmc.c:211: for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
   0204                     452 00155$:
   0204 11 E8 03      [10]  453 	ld	de,#0x03E8
   0207                     454 00132$:
                            455 ;mmc.c:212: if (send_cmd(cmd, 0) == 0) break;
   0207 C5            [11]  456 	push	bc
   0208 D5            [11]  457 	push	de
   0209 21 00 00      [10]  458 	ld	hl,#0x0000
   020C E5            [11]  459 	push	hl
   020D 21 00 00      [10]  460 	ld	hl,#0x0000
   0210 E5            [11]  461 	push	hl
   0211 C5            [11]  462 	push	bc
   0212 33            [ 6]  463 	inc	sp
   0213 CDr2Cr00      [17]  464 	call	_send_cmd
   0216 F1            [10]  465 	pop	af
   0217 F1            [10]  466 	pop	af
   0218 33            [ 6]  467 	inc	sp
   0219 7D            [ 4]  468 	ld	a,l
   021A D1            [10]  469 	pop	de
   021B C1            [10]  470 	pop	bc
   021C B7            [ 4]  471 	or	a, a
   021D 28 11         [12]  472 	jr	Z,00117$
                            473 ;mmc.c:213: DLY_US(1000);
   021F C5            [11]  474 	push	bc
   0220 D5            [11]  475 	push	de
   0221 3E E8         [ 7]  476 	ld	a,#0xE8
   0223 F5            [11]  477 	push	af
   0224 33            [ 6]  478 	inc	sp
   0225 CDr00r00      [17]  479 	call	_dly_us
   0228 33            [ 6]  480 	inc	sp
   0229 D1            [10]  481 	pop	de
   022A C1            [10]  482 	pop	bc
                            483 ;mmc.c:211: for (tmr = 1000; tmr; tmr--) {			/* Wait for leaving idle state */
   022B 1B            [ 6]  484 	dec	de
   022C 7A            [ 4]  485 	ld	a,d
   022D B3            [ 4]  486 	or	a,e
   022E 20 D7         [12]  487 	jr	NZ,00132$
   0230                     488 00117$:
                            489 ;mmc.c:215: if (!tmr || send_cmd(CMD16, 512) != 0)			/* Set R/W block length to 512 */
   0230 7A            [ 4]  490 	ld	a,d
   0231 B3            [ 4]  491 	or	a,e
   0232 28 18         [12]  492 	jr	Z,00118$
   0234 C5            [11]  493 	push	bc
   0235 21 00 00      [10]  494 	ld	hl,#0x0000
   0238 E5            [11]  495 	push	hl
   0239 21 00 02      [10]  496 	ld	hl,#0x0200
   023C E5            [11]  497 	push	hl
   023D 3E 50         [ 7]  498 	ld	a,#0x50
   023F F5            [11]  499 	push	af
   0240 33            [ 6]  500 	inc	sp
   0241 CDr2Cr00      [17]  501 	call	_send_cmd
   0244 F1            [10]  502 	pop	af
   0245 F1            [10]  503 	pop	af
   0246 33            [ 6]  504 	inc	sp
   0247 7D            [ 4]  505 	ld	a,l
   0248 C1            [10]  506 	pop	bc
   0249 B7            [ 4]  507 	or	a, a
   024A 28 02         [12]  508 	jr	Z,00125$
   024C                     509 00118$:
                            510 ;mmc.c:216: ty = 0;
   024C 0E 00         [ 7]  511 	ld	c,#0x00
   024E                     512 00125$:
                            513 ;mmc.c:219: CardType = ty;
   024E 21r00r02      [10]  514 	ld	hl,#_CardType + 0
   0251 71            [ 7]  515 	ld	(hl), c
                            516 ;mmc.c:220: release_spi();
   0252 C5            [11]  517 	push	bc
   0253 CDr25r00      [17]  518 	call	_release_spi
   0256 C1            [10]  519 	pop	bc
                            520 ;mmc.c:222: return ty ? 0 : STA_NOINIT;
   0257 79            [ 4]  521 	ld	a,c
   0258 B7            [ 4]  522 	or	a, a
   0259 28 04         [12]  523 	jr	Z,00138$
   025B 2E 00         [ 7]  524 	ld	l,#0x00
   025D 18 02         [12]  525 	jr	00139$
   025F                     526 00138$:
   025F 2E 01         [ 7]  527 	ld	l,#0x01
   0261                     528 00139$:
   0261 DD F9         [10]  529 	ld	sp, ix
   0263 DD E1         [14]  530 	pop	ix
   0265 C9            [10]  531 	ret
                            532 ;mmc.c:231: DRESULT disk_readp (
                            533 ;	---------------------------------
                            534 ; Function disk_readp
                            535 ; ---------------------------------
   0266                     536 _disk_readp::
   0266 DD E5         [15]  537 	push	ix
   0268 DD 21 00 00   [14]  538 	ld	ix,#0
   026C DD 39         [15]  539 	add	ix,sp
   026E 21 F4 FF      [10]  540 	ld	hl,#-12
   0271 39            [11]  541 	add	hl,sp
   0272 F9            [ 6]  542 	ld	sp,hl
                            543 ;mmc.c:238: BYTE *buff_sec = buffer;
                            544 ;mmc.c:243: if (!(CardType & CT_BLOCK)) sector *= 512;	/* Convert to byte address if needed */
   0273 FD 21r00r02   [14]  545 	ld	iy,#_CardType
   0277 FD CB 00 5E   [20]  546 	bit	3, 0 (iy)
   027B 20 16         [12]  547 	jr	NZ,00102$
   027D F5            [11]  548 	push	af
   027E F1            [10]  549 	pop	af
   027F 06 09         [ 7]  550 	ld	b,#0x09
   0281                     551 00230$:
   0281 DD CB 06 26   [23]  552 	sla	6 (ix)
   0285 DD CB 07 16   [23]  553 	rl	7 (ix)
   0289 DD CB 08 16   [23]  554 	rl	8 (ix)
   028D DD CB 09 16   [23]  555 	rl	9 (ix)
   0291 10 EE         [13]  556 	djnz	00230$
   0293                     557 00102$:
                            558 ;mmc.c:269: *buff++ = rcvr_mmc();
   0293 DD 7E 04      [19]  559 	ld	a,4 (ix)
   0296 DD 77 FA      [19]  560 	ld	-6 (ix),a
   0299 DD 7E 05      [19]  561 	ld	a,5 (ix)
   029C DD 77 FB      [19]  562 	ld	-5 (ix),a
                            563 ;mmc.c:248: while(count--)
   029F DD 7E 0C      [19]  564 	ld	a,12 (ix)
   02A2 DD 77 FE      [19]  565 	ld	-2 (ix),a
   02A5 DD 7E 0D      [19]  566 	ld	a,13 (ix)
   02A8 DD 77 FF      [19]  567 	ld	-1 (ix),a
                            568 ;mmc.c:246: if(buffer_sector == sector) {
   02AB 3Ar00r00      [13]  569 	ld	a,(#_buffer_sector + 0)
   02AE DD 96 06      [19]  570 	sub	a, 6 (ix)
   02B1 20 49         [12]  571 	jr	NZ,00107$
   02B3 3Ar01r00      [13]  572 	ld	a,(#_buffer_sector + 1)
   02B6 DD 96 07      [19]  573 	sub	a, 7 (ix)
   02B9 20 41         [12]  574 	jr	NZ,00107$
   02BB 3Ar02r00      [13]  575 	ld	a,(#_buffer_sector + 2)
   02BE DD 96 08      [19]  576 	sub	a, 8 (ix)
   02C1 20 39         [12]  577 	jr	NZ,00107$
   02C3 3Ar03r00      [13]  578 	ld	a,(#_buffer_sector + 3)
   02C6 DD 96 09      [19]  579 	sub	a, 9 (ix)
   02C9 20 31         [12]  580 	jr	NZ,00107$
                            581 ;mmc.c:247: buff_sec += offset;  // skip to requested bytes
   02CB 3Er00         [ 7]  582 	ld	a,#<(_buffer)
   02CD DD 86 0A      [19]  583 	add	a, 10 (ix)
   02D0 4F            [ 4]  584 	ld	c,a
   02D1 3Es00         [ 7]  585 	ld	a,#>(_buffer)
   02D3 DD 8E 0B      [19]  586 	adc	a, 11 (ix)
   02D6 47            [ 4]  587 	ld	b,a
                            588 ;mmc.c:248: while(count--)
   02D7 DD 5E FA      [19]  589 	ld	e,-6 (ix)
   02DA DD 56 FB      [19]  590 	ld	d,-5 (ix)
   02DD E5            [11]  591 	push	hl
   02DE DD 6E FE      [19]  592 	ld	l,-2 (ix)
   02E1 DD 66 FF      [19]  593 	ld	h,-1 (ix)
   02E4 E5            [11]  594 	push	hl
   02E5 FD E1         [14]  595 	pop	iy
   02E7 E1            [10]  596 	pop	hl
   02E8                     597 00103$:
   02E8 FD E5         [15]  598 	push	iy
   02EA E1            [10]  599 	pop	hl
   02EB FD 2B         [10]  600 	dec	iy
   02ED 7C            [ 4]  601 	ld	a,h
   02EE B5            [ 4]  602 	or	a,l
   02EF 28 06         [12]  603 	jr	Z,00105$
                            604 ;mmc.c:249: *buff++ = *buff_sec++;
   02F1 0A            [ 7]  605 	ld	a,(bc)
   02F2 03            [ 6]  606 	inc	bc
   02F3 12            [ 7]  607 	ld	(de),a
   02F4 13            [ 6]  608 	inc	de
   02F5 18 F1         [12]  609 	jr	00103$
   02F7                     610 00105$:
                            611 ;mmc.c:251: return RES_OK;
   02F7 2E 00         [ 7]  612 	ld	l,#0x00
   02F9 C3r31r05      [10]  613 	jp	00139$
   02FC                     614 00107$:
                            615 ;mmc.c:254: res = RES_ERROR;
   02FC DD 36 F8 01   [19]  616 	ld	-8 (ix),#0x01
                            617 ;mmc.c:255: if (send_cmd(CMD17, sector) == 0) {		/* READ_SINGLE_BLOCK */
   0300 DD 6E 08      [19]  618 	ld	l,8 (ix)
   0303 DD 66 09      [19]  619 	ld	h,9 (ix)
   0306 E5            [11]  620 	push	hl
   0307 DD 6E 06      [19]  621 	ld	l,6 (ix)
   030A DD 66 07      [19]  622 	ld	h,7 (ix)
   030D E5            [11]  623 	push	hl
   030E 3E 51         [ 7]  624 	ld	a,#0x51
   0310 F5            [11]  625 	push	af
   0311 33            [ 6]  626 	inc	sp
   0312 CDr2Cr00      [17]  627 	call	_send_cmd
   0315 F1            [10]  628 	pop	af
   0316 F1            [10]  629 	pop	af
   0317 33            [ 6]  630 	inc	sp
   0318 DD 75 F9      [19]  631 	ld	-7 (ix), l
   031B 7D            [ 4]  632 	ld	a, l
   031C B7            [ 4]  633 	or	a, a
   031D C2r2Br05      [10]  634 	jp	NZ,00135$
                            635 ;mmc.c:257: tmr = 1000;
   0320 21 E8 03      [10]  636 	ld	hl,#0x03E8
   0323 E3            [19]  637 	ex	(sp), hl
                            638 ;mmc.c:258: do {							/* Wait for data packet in timeout of 100ms */
   0324                     639 00109$:
                            640 ;mmc.c:259: DLY_US(100);
   0324 3E 64         [ 7]  641 	ld	a,#0x64
   0326 F5            [11]  642 	push	af
   0327 33            [ 6]  643 	inc	sp
   0328 CDr00r00      [17]  644 	call	_dly_us
   032B 33            [ 6]  645 	inc	sp
                            646 ;mmc.c:260: d = rcvr_mmc();
   032C CDr0Dr00      [17]  647 	call	_rcvr_mmc
                            648 ;mmc.c:261: } while (d == 0xFF && --tmr);
   032F DD 75 F9      [19]  649 	ld	-7 (ix), l
   0332 7D            [ 4]  650 	ld	a, l
   0333 3C            [ 4]  651 	inc	a
   0334 20 24         [12]  652 	jr	NZ,00111$
   0336 DD 7E F4      [19]  653 	ld	a,-12 (ix)
   0339 C6 FF         [ 7]  654 	add	a,#0xFF
   033B DD 77 FC      [19]  655 	ld	-4 (ix),a
   033E DD 7E F5      [19]  656 	ld	a,-11 (ix)
   0341 CE FF         [ 7]  657 	adc	a,#0xFF
   0343 DD 77 FD      [19]  658 	ld	-3 (ix),a
   0346 DD 7E FC      [19]  659 	ld	a,-4 (ix)
   0349 DD 77 F4      [19]  660 	ld	-12 (ix),a
   034C DD 7E FD      [19]  661 	ld	a,-3 (ix)
   034F DD 77 F5      [19]  662 	ld	-11 (ix),a
   0352 DD 7E FD      [19]  663 	ld	a,-3 (ix)
   0355 DD B6 FC      [19]  664 	or	a,-4 (ix)
   0358 20 CA         [12]  665 	jr	NZ,00109$
   035A                     666 00111$:
                            667 ;mmc.c:263: if (d == 0xFE) {				/* A data packet arrived */
   035A DD 7E F9      [19]  668 	ld	a,-7 (ix)
   035D D6 FE         [ 7]  669 	sub	a, #0xFE
   035F C2r2Br05      [10]  670 	jp	NZ,00135$
                            671 ;mmc.c:266: if((!offset) && (count == 512)) {
   0362 DD 7E 0B      [19]  672 	ld	a,11 (ix)
   0365 DD B6 0A      [19]  673 	or	a,10 (ix)
   0368 C2r35r04      [10]  674 	jp	NZ,00129$
   036B DD 7E 0C      [19]  675 	ld	a,12 (ix)
   036E B7            [ 4]  676 	or	a, a
   036F C2r35r04      [10]  677 	jp	NZ,00129$
   0372 DD 7E 0D      [19]  678 	ld	a,13 (ix)
   0375 D6 02         [ 7]  679 	sub	a, #0x02
   0377 C2r35r04      [10]  680 	jp	NZ,00129$
                            681 ;mmc.c:268: for(c=0;c<64;c++) {
   037A DD 36 FC 40   [19]  682 	ld	-4 (ix),#0x40
   037E                     683 00138$:
                            684 ;mmc.c:269: *buff++ = rcvr_mmc();
   037E DD 6E 04      [19]  685 	ld	l,4 (ix)
   0381 DD 66 05      [19]  686 	ld	h,5 (ix)
   0384 E5            [11]  687 	push	hl
   0385 CDr0Dr00      [17]  688 	call	_rcvr_mmc
   0388 7D            [ 4]  689 	ld	a,l
   0389 E1            [10]  690 	pop	hl
   038A 77            [ 7]  691 	ld	(hl),a
   038B 23            [ 6]  692 	inc	hl
   038C DD 75 04      [19]  693 	ld	4 (ix),l
   038F DD 74 05      [19]  694 	ld	5 (ix),h
                            695 ;mmc.c:270: *buff++ = rcvr_mmc();
   0392 DD 6E 04      [19]  696 	ld	l,4 (ix)
   0395 DD 66 05      [19]  697 	ld	h,5 (ix)
   0398 E5            [11]  698 	push	hl
   0399 CDr0Dr00      [17]  699 	call	_rcvr_mmc
   039C 7D            [ 4]  700 	ld	a,l
   039D E1            [10]  701 	pop	hl
   039E 77            [ 7]  702 	ld	(hl),a
   039F 23            [ 6]  703 	inc	hl
   03A0 DD 75 04      [19]  704 	ld	4 (ix),l
   03A3 DD 74 05      [19]  705 	ld	5 (ix),h
                            706 ;mmc.c:271: *buff++ = rcvr_mmc();
   03A6 DD 6E 04      [19]  707 	ld	l,4 (ix)
   03A9 DD 66 05      [19]  708 	ld	h,5 (ix)
   03AC E5            [11]  709 	push	hl
   03AD CDr0Dr00      [17]  710 	call	_rcvr_mmc
   03B0 7D            [ 4]  711 	ld	a,l
   03B1 E1            [10]  712 	pop	hl
   03B2 77            [ 7]  713 	ld	(hl),a
   03B3 23            [ 6]  714 	inc	hl
   03B4 DD 75 04      [19]  715 	ld	4 (ix),l
   03B7 DD 74 05      [19]  716 	ld	5 (ix),h
                            717 ;mmc.c:272: *buff++ = rcvr_mmc();
   03BA DD 6E 04      [19]  718 	ld	l,4 (ix)
   03BD DD 66 05      [19]  719 	ld	h,5 (ix)
   03C0 E5            [11]  720 	push	hl
   03C1 CDr0Dr00      [17]  721 	call	_rcvr_mmc
   03C4 7D            [ 4]  722 	ld	a,l
   03C5 E1            [10]  723 	pop	hl
   03C6 77            [ 7]  724 	ld	(hl),a
   03C7 23            [ 6]  725 	inc	hl
   03C8 DD 75 04      [19]  726 	ld	4 (ix),l
   03CB DD 74 05      [19]  727 	ld	5 (ix),h
                            728 ;mmc.c:273: *buff++ = rcvr_mmc();
   03CE DD 6E 04      [19]  729 	ld	l,4 (ix)
   03D1 DD 66 05      [19]  730 	ld	h,5 (ix)
   03D4 E5            [11]  731 	push	hl
   03D5 CDr0Dr00      [17]  732 	call	_rcvr_mmc
   03D8 7D            [ 4]  733 	ld	a,l
   03D9 E1            [10]  734 	pop	hl
   03DA 77            [ 7]  735 	ld	(hl),a
   03DB 23            [ 6]  736 	inc	hl
   03DC DD 75 04      [19]  737 	ld	4 (ix),l
   03DF DD 74 05      [19]  738 	ld	5 (ix),h
                            739 ;mmc.c:274: *buff++ = rcvr_mmc();
   03E2 DD 6E 04      [19]  740 	ld	l,4 (ix)
   03E5 DD 66 05      [19]  741 	ld	h,5 (ix)
   03E8 E5            [11]  742 	push	hl
   03E9 CDr0Dr00      [17]  743 	call	_rcvr_mmc
   03EC 7D            [ 4]  744 	ld	a,l
   03ED E1            [10]  745 	pop	hl
   03EE 77            [ 7]  746 	ld	(hl),a
   03EF 23            [ 6]  747 	inc	hl
   03F0 DD 75 04      [19]  748 	ld	4 (ix),l
   03F3 DD 74 05      [19]  749 	ld	5 (ix),h
                            750 ;mmc.c:275: *buff++ = rcvr_mmc();
   03F6 DD 6E 04      [19]  751 	ld	l,4 (ix)
   03F9 DD 66 05      [19]  752 	ld	h,5 (ix)
   03FC E5            [11]  753 	push	hl
   03FD CDr0Dr00      [17]  754 	call	_rcvr_mmc
   0400 7D            [ 4]  755 	ld	a,l
   0401 E1            [10]  756 	pop	hl
   0402 77            [ 7]  757 	ld	(hl),a
   0403 23            [ 6]  758 	inc	hl
   0404 DD 75 04      [19]  759 	ld	4 (ix),l
   0407 DD 74 05      [19]  760 	ld	5 (ix),h
                            761 ;mmc.c:276: *buff++ = rcvr_mmc();
   040A DD 6E 04      [19]  762 	ld	l,4 (ix)
   040D DD 66 05      [19]  763 	ld	h,5 (ix)
   0410 E5            [11]  764 	push	hl
   0411 CDr0Dr00      [17]  765 	call	_rcvr_mmc
   0414 7D            [ 4]  766 	ld	a,l
   0415 E1            [10]  767 	pop	hl
   0416 77            [ 7]  768 	ld	(hl),a
   0417 23            [ 6]  769 	inc	hl
   0418 DD 75 04      [19]  770 	ld	4 (ix),l
   041B DD 74 05      [19]  771 	ld	5 (ix),h
   041E DD 7E FC      [19]  772 	ld	a,-4 (ix)
   0421 C6 FF         [ 7]  773 	add	a,#0xFF
   0423 DD 77 FC      [19]  774 	ld	-4 (ix),a
                            775 ;mmc.c:268: for(c=0;c<64;c++) {
   0426 B7            [ 4]  776 	or	a, a
   0427 C2r7Er03      [10]  777 	jp	NZ,00138$
                            778 ;mmc.c:278: skip_mmc(2);
   042A 21 02 00      [10]  779 	ld	hl,#0x0002
   042D E5            [11]  780 	push	hl
   042E CDr17r00      [17]  781 	call	_skip_mmc
   0431 F1            [10]  782 	pop	af
   0432 C3r27r05      [10]  783 	jp	00130$
   0435                     784 00129$:
                            785 ;mmc.c:281: bc = 512 - offset - count;
   0435 AF            [ 4]  786 	xor	a, a
   0436 DD 96 0A      [19]  787 	sub	a, 10 (ix)
   0439 67            [ 4]  788 	ld	h,a
   043A 3E 02         [ 7]  789 	ld	a,#0x02
   043C DD 9E 0B      [19]  790 	sbc	a, 11 (ix)
   043F 6F            [ 4]  791 	ld	l,a
   0440 7C            [ 4]  792 	ld	a,h
   0441 DD 96 0C      [19]  793 	sub	a, 12 (ix)
   0444 67            [ 4]  794 	ld	h,a
   0445 7D            [ 4]  795 	ld	a,l
   0446 DD 9E 0D      [19]  796 	sbc	a, 13 (ix)
   0449 DD 74 F6      [19]  797 	ld	-10 (ix), h
   044C DD 77 F7      [19]  798 	ld	-9 (ix), a
                            799 ;mmc.c:284: while(offset--)
   044F DD 36 FCr00   [19]  800 	ld	-4 (ix),#<(_buffer)
   0453 DD 36 FDs00   [19]  801 	ld	-3 (ix),#>(_buffer)
   0457 DD 5E 0A      [19]  802 	ld	e,10 (ix)
   045A DD 56 0B      [19]  803 	ld	d,11 (ix)
   045D                     804 00113$:
   045D 6B            [ 4]  805 	ld	l, e
   045E 62            [ 4]  806 	ld	h, d
   045F 1B            [ 6]  807 	dec	de
   0460 7C            [ 4]  808 	ld	a,h
   0461 B5            [ 4]  809 	or	a,l
   0462 28 17         [12]  810 	jr	Z,00115$
                            811 ;mmc.c:285: *buff_sec++ = rcvr_mmc();
   0464 D5            [11]  812 	push	de
   0465 CDr0Dr00      [17]  813 	call	_rcvr_mmc
   0468 7D            [ 4]  814 	ld	a,l
   0469 D1            [10]  815 	pop	de
   046A DD 6E FC      [19]  816 	ld	l,-4 (ix)
   046D DD 66 FD      [19]  817 	ld	h,-3 (ix)
   0470 77            [ 7]  818 	ld	(hl),a
   0471 DD 34 FC      [23]  819 	inc	-4 (ix)
   0474 20 E7         [12]  820 	jr	NZ,00113$
   0476 DD 34 FD      [23]  821 	inc	-3 (ix)
   0479 18 E2         [12]  822 	jr	00113$
   047B                     823 00115$:
                            824 ;mmc.c:288: if (buff) {	/* Store data to the memory */
   047B DD 7E 05      [19]  825 	ld	a,5 (ix)
   047E DD B6 04      [19]  826 	or	a,4 (ix)
   0481 28 3B         [12]  827 	jr	Z,00157$
                            828 ;mmc.c:289: do
   0483 DD 4E FA      [19]  829 	ld	c,-6 (ix)
   0486 DD 46 FB      [19]  830 	ld	b,-5 (ix)
   0489 DD 5E FC      [19]  831 	ld	e,-4 (ix)
   048C DD 56 FD      [19]  832 	ld	d,-3 (ix)
   048F DD 7E FE      [19]  833 	ld	a,-2 (ix)
   0492 DD 77 FA      [19]  834 	ld	-6 (ix),a
   0495 DD 7E FF      [19]  835 	ld	a,-1 (ix)
   0498 DD 77 FB      [19]  836 	ld	-5 (ix),a
   049B                     837 00116$:
                            838 ;mmc.c:290: *buff_sec++ = *buff++ = rcvr_mmc();
   049B C5            [11]  839 	push	bc
   049C D5            [11]  840 	push	de
   049D CDr0Dr00      [17]  841 	call	_rcvr_mmc
   04A0 7D            [ 4]  842 	ld	a,l
   04A1 D1            [10]  843 	pop	de
   04A2 C1            [10]  844 	pop	bc
   04A3 02            [ 7]  845 	ld	(bc),a
   04A4 03            [ 6]  846 	inc	bc
   04A5 12            [ 7]  847 	ld	(de),a
   04A6 13            [ 6]  848 	inc	de
                            849 ;mmc.c:291: while (--count);
   04A7 DD 6E FA      [19]  850 	ld	l,-6 (ix)
   04AA DD 66 FB      [19]  851 	ld	h,-5 (ix)
   04AD 2B            [ 6]  852 	dec	hl
   04AE DD 75 FA      [19]  853 	ld	-6 (ix),l
   04B1 DD 74 FB      [19]  854 	ld	-5 (ix), h
   04B4 7C            [ 4]  855 	ld	a, h
   04B5 DD B6 FA      [19]  856 	or	a,-6 (ix)
   04B8 20 E1         [12]  857 	jr	NZ,00116$
   04BA 4B            [ 4]  858 	ld	c, e
   04BB 42            [ 4]  859 	ld	b, d
   04BC 18 28         [12]  860 	jr	00159$
                            861 ;mmc.c:293: do {
   04BE                     862 00157$:
   04BE DD 6E FC      [19]  863 	ld	l,-4 (ix)
   04C1 DD 66 FD      [19]  864 	ld	h,-3 (ix)
   04C4 DD 5E FE      [19]  865 	ld	e,-2 (ix)
   04C7 DD 56 FF      [19]  866 	ld	d,-1 (ix)
   04CA                     867 00119$:
                            868 ;mmc.c:294: *buff_sec++ = d = rcvr_mmc();
   04CA E5            [11]  869 	push	hl
   04CB D5            [11]  870 	push	de
   04CC CDr0Dr00      [17]  871 	call	_rcvr_mmc
   04CF 7D            [ 4]  872 	ld	a,l
   04D0 D1            [10]  873 	pop	de
   04D1 E1            [10]  874 	pop	hl
   04D2 47            [ 4]  875 	ld	b,a
   04D3 77            [ 7]  876 	ld	(hl),a
   04D4 23            [ 6]  877 	inc	hl
                            878 ;mmc.c:295: FORWARD(d);
   04D5 E5            [11]  879 	push	hl
   04D6 D5            [11]  880 	push	de
   04D7 C5            [11]  881 	push	bc
   04D8 33            [ 6]  882 	inc	sp
   04D9 CDr0Cr00      [17]  883 	call	_forward
   04DC 33            [ 6]  884 	inc	sp
   04DD D1            [10]  885 	pop	de
   04DE E1            [10]  886 	pop	hl
                            887 ;mmc.c:296: } while (--count);
   04DF 1B            [ 6]  888 	dec	de
   04E0 7A            [ 4]  889 	ld	a,d
   04E1 B3            [ 4]  890 	or	a,e
   04E2 20 E6         [12]  891 	jr	NZ,00119$
                            892 ;mmc.c:300: while(bc--)
   04E4 4D            [ 4]  893 	ld	c, l
   04E5 44            [ 4]  894 	ld	b, h
   04E6                     895 00159$:
   04E6 DD 7E F6      [19]  896 	ld	a,-10 (ix)
   04E9 DD 77 FC      [19]  897 	ld	-4 (ix),a
   04EC DD 7E F7      [19]  898 	ld	a,-9 (ix)
   04EF DD 77 FD      [19]  899 	ld	-3 (ix),a
   04F2                     900 00125$:
   04F2 DD 56 FC      [19]  901 	ld	d,-4 (ix)
   04F5 DD 5E FD      [19]  902 	ld	e,-3 (ix)
   04F8 DD 6E FC      [19]  903 	ld	l,-4 (ix)
   04FB DD 66 FD      [19]  904 	ld	h,-3 (ix)
   04FE 2B            [ 6]  905 	dec	hl
   04FF DD 75 FC      [19]  906 	ld	-4 (ix),l
   0502 DD 74 FD      [19]  907 	ld	-3 (ix),h
   0505 7B            [ 4]  908 	ld	a,e
   0506 B2            [ 4]  909 	or	a,d
   0507 28 0A         [12]  910 	jr	Z,00127$
                            911 ;mmc.c:301: *buff_sec++ = rcvr_mmc();
   0509 C5            [11]  912 	push	bc
   050A CDr0Dr00      [17]  913 	call	_rcvr_mmc
   050D 7D            [ 4]  914 	ld	a,l
   050E C1            [10]  915 	pop	bc
   050F 02            [ 7]  916 	ld	(bc),a
   0510 03            [ 6]  917 	inc	bc
   0511 18 DF         [12]  918 	jr	00125$
   0513                     919 00127$:
                            920 ;mmc.c:304: skip_mmc(2);
   0513 21 02 00      [10]  921 	ld	hl,#0x0002
   0516 E5            [11]  922 	push	hl
   0517 CDr17r00      [17]  923 	call	_skip_mmc
   051A F1            [10]  924 	pop	af
                            925 ;mmc.c:306: buffer_sector = sector;
   051B 11r00r00      [10]  926 	ld	de, #_buffer_sector
   051E 21 12 00      [10]  927 	ld	hl, #18
   0521 39            [11]  928 	add	hl, sp
   0522 01 04 00      [10]  929 	ld	bc, #4
   0525 ED B0         [21]  930 	ldir
   0527                     931 00130$:
                            932 ;mmc.c:309: res = RES_OK;
   0527 DD 36 F8 00   [19]  933 	ld	-8 (ix),#0x00
   052B                     934 00135$:
                            935 ;mmc.c:313: release_spi();
   052B CDr25r00      [17]  936 	call	_release_spi
                            937 ;mmc.c:315: return res;
   052E DD 6E F8      [19]  938 	ld	l,-8 (ix)
   0531                     939 00139$:
   0531 DD F9         [10]  940 	ld	sp, ix
   0533 DD E1         [14]  941 	pop	ix
   0535 C9            [10]  942 	ret
                            943 	.area _CODE
                            944 	.area _INITIALIZER
   0000                     945 __xinit__buffer_sector:
   0000 FF FF FF FF         946 	.byte #0xFF,#0xFF,#0xFF,#0xFF	; 4294967295
                            947 	.area _CABS (ABS)
